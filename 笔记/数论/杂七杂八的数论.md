# 杂七杂八的数论

## **一.斐波那契数列相关**
### 1.1
定义$F$为斐波那契数列,如果$F_i$能被$k$整除,那么对于每一个$j$,$F_{i*j}$也能被$k$整除 (CF2033F)
### 1.2
斐波那契数列 MOD k,会得到一个周期数列

## **二.几何**
### 2.1 *阿基米德三角形*
抛物线与直线所围成的面积$S_{AOB}$为阿基米德三角形$\triangle ABP$的$\frac{2}{3}$ (阿基米德三角形)
![avatar](https://bkimg.cdn.bcebos.com/pic/adaf2edda3cc7cd97c3f7cf13201213fb80e918c?x-bce-process=image/format,f_auto/watermark,image_d2F0ZXIvYmFpa2UyNzI,g_7,xp_5,yp_5,P_20/resize,m_lfit,limit_1,h_1080)

## **三.异或相关**
### 3.1
从$0$到$x$所有数的异或满足以下公式  
$$ XOR(0, x) = \begin{cases} x & \text{if } x \equiv 0 \pmod{4} \\ 1 & \text{if } x \equiv 1 \pmod{4} \\ x + 1 & \text{if } x \equiv 2 \pmod{4} \\ 0 & \text{if } x \equiv 3 \pmod{4} \end{cases}$$
### 3.2
$\alpha\oplus\beta\leq\alpha+\beta$ 异或相当于不带进位的加法  
$\alpha\oplus\beta\ge\alpha-\beta$ 异或相当于不借位的减法
$lcm(\alpha,\beta)\ge2\cdot\max(\alpha,\beta)>\alpha\oplus\beta$
### 3.3
O(1)求[l, r]所有数的异或和
```cpp
auto XOR = [&](int x) -> LL {
    if (x % 4 == 0) return x;
    if (x % 4 == 1) return 1;
    if (x % 4 == 2) return x + 1;
    if (x % 4 == 3) return 0;
};
auto qry = [&](int l, int r) -> LL {
    return XOR(r) ^ XOR(l - 1);
};
```

## **四.取模运算**
### 4.1 *逆元* 
**$a / b == a * b^{-1}$**
给定整数a，满足$gcd(a,m)=1$，方程$ax\mod m = 1$，x的所有解是a在模m意义下的逆，记作$a^{-1}$
$(a+b)\mod p = (a\mod p + b\mod p) \mod p$
$(a/b)\mod p = (a\mod p * b^{-1} \mod p) \mod p$

### 4.2 *cpp模板*
```cpp
template<const LL MOD>
struct ModInt{
    LL x;
    ModInt(LL n = 0){ x = n;}
    ModInt<MOD> qmi(LL k){
        ModInt<MOD> res = 1;
        ModInt a = *this;
        while (k){
            if (k&1) (res.x *= a.x) %= MOD;
            (a.x *= a.x) %= MOD;
            k /= 2;
        }
        return res;
    }
    ModInt<MOD> inv(){ ModInt<MOD> a = *this; return a.qmi(MOD-2);}
    ModInt<MOD> friend operator+(ModInt<MOD> a,ModInt<MOD> b){ return (a.x + b.x) % MOD;}
    ModInt<MOD> friend operator-(ModInt<MOD> a,ModInt<MOD> b){ return (a.x - b.x + MOD) % MOD;}
    ModInt<MOD> friend operator*(ModInt<MOD> a,ModInt<MOD> b){ return a.x % MOD * b.x % MOD;}
    ModInt<MOD> friend operator/(ModInt<MOD> a,ModInt<MOD> b){ return a * b.inv();}
    ModInt<MOD> friend operator<=(ModInt<MOD> a,ModInt<MOD> b){ return a.x <= b.x;}
    ModInt<MOD> friend operator< (ModInt<MOD> a,ModInt<MOD> b){ return a.x <  b.x;}
    ModInt<MOD> friend operator>=(ModInt<MOD> a,ModInt<MOD> b){ return a.x >= b.x;}
    ModInt<MOD> friend operator> (ModInt<MOD> a,ModInt<MOD> b){ return a.x >  b.x;}
    ModInt<MOD> friend operator==(ModInt<MOD> a,ModInt<MOD> b){ return a.x == b.x;}
    friend ostream& operator<< (ostream& out,ModInt<MOD>& a){ return out << a.x;}
    friend istream& operator>> (istream& in, ModInt<MOD>& a){ return  in >> a.x;}
    ModInt<MOD> operator+= (const ModInt<MOD>& a){ return *this = x + a;}
    ModInt<MOD> operator-= (const ModInt<MOD>& a){ return *this = x - a;}
    ModInt<MOD> operator*= (const ModInt<MOD>& a){ return *this = x * a;}
    ModInt<MOD> operator/= (const ModInt<MOD>& a){ return *this = x / a;}
};
```

## **五.排列组合**
### 5.1 *卢卡斯定理*
**结论 :** 
**$lucas(n,m,p) = {{n \mod p} \choose {m \mod p}} \cdot lucas(\lfloor \frac{n}{p} \rfloor, \lfloor \frac{m}{p} \rfloor, p)$**  
**引入**  
**qs.** 杨辉三角第n行有多少个奇数？  
**ans.** 将$n$化为二进制，设二进制表示中有$x$个1，则杨辉三角的第$n$行有$2^x$个奇数  

## **六.筛法**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e8+10;

int sieve[N];
int prime[N];

/*
埃拉托斯特尼筛法
对于任意一个大于 1 的正整数 n，
那么它的 x 倍就是合数（x > 1）。
利用这个结论，我们可以避免很多次不必要的检测。

如果我们从小到大考虑每个数，
然后同时把当前这个数的所有（比自己大的）倍数记为合数，
那么运行结束的时候没有被标记的数就是素数了。
*/
int Era(int n){
    int k = 0;
    for (int i=2;i*i<=n;i++){
        if (!sieve[i]){
            for (int j=i*i;j<=n;j+=i){
                sieve[j] = 1;
            }
        }
    }
    for (int i=2;i<=n;i++){
        if (!sieve[i]){
            prime[k++] = i;
        }
    }
    return k;
}

/*
欧拉筛法
*/
int Eular(int n){
    int k = 0;
    for (int i=2;i<=n;i++){
        if (!sieve[i]){
            prime[k++] = i;
        }   
        for (int j=0;j<k;j++){
            if (i * prime[j] > n) break;
            sieve[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return k;
}
```

## **七.欧几里得**
### 7.1 辗转相除求gcd
```cpp
int gcd(int a, int b){
    return b == 0 ? a : gcd(b, a % b);
}
```
### 7.2 拓展欧几里得
1. 裴属定理：$ax + by = \gcd(a, b)$
2. 根据欧几里得求解gcd的过程，可将上述式子变化成  
   $$by + (a \mod b)x = \gcd(b, a \mod b), b \neq 0  $$
   $$by + (a - \lfloor\frac{a}{b}\rfloor\times b)\times x=\gcd(b,a \mod b), b \neq 0$$
   $$by + ax - \lfloor\frac{a}{b}\rfloor\times b\times x = \gcd(b,a \mod b), b \neq 0$$
   $$ax + (y - \lfloor\frac{a}{b}\rfloor\times x)\times b = \gcd(b, a \mod b), b \neq 0$$
``` cpp
int exgcd(int a, int b, int &x, int &y){
    if (!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

## **八.概率**
喵喵喵
## **九.期望**
喵喵喵
## **十.其他**
### *中位数定理*
当一个数组允许对其任意一个元素进行加一或减一操作，
使之最终数组中元素相同，则最小操作次数所对应最终要变成的数就
是这个数组的中位数
### 妙妙数学
喵喵喵