## 重链剖分
### 例题：2025杭电暑假多校第二场P1009
- 题意：  
  给定一棵节点上带权值的树  
  查询：u到v的最短路径上最大点权权值
  修改：x，所有和x相连的点加上z
- 典型重链剖分
~~~cpp
#include <bits/stdc++.h>
#define lc p << 1
#define rc p << 1 | 1
using namespace std;
using LL = long long;

struct SegTree{
    struct node{
        LL l, r, val;
        node (){l = r = val = 0;}
    };
    vector<node> seg;
    vector<LL> a;
    SegTree (int n){
        seg.resize((n << 2) + 10);
        a.resize(n + 1, 0);
    }
    void build(int p, int l, int r){
        seg[p].l = l, seg[p].r = r;
        if (l == r){
            seg[p].val = a[l];
            return;
        }
        build(lc, l, (l + r) / 2);
        build(rc, (l + r) / 2 + 1, r);
        seg[p].val = max(seg[lc].val, seg[rc].val);
    }
    void upd(int p, int id, int x){
        if (seg[p].l == seg[p].r){
            seg[p].val += x;
            return;
        }
        int m = (seg[p].l + seg[p].r) / 2;
        if (id <= m) upd(lc, id, x);
        else upd(rc, id, x);
        seg[p].val = max(seg[lc].val, seg[rc].val);
    }
    LL qry(int p, int l, int r){
        if (l <= seg[p].l && seg[p].r <= r) return seg[p].val;
        LL res = 0;
        int m = (seg[p].l + seg[p].r) / 2;
        if (l <= m) res = max(res, qry(lc, l, r));
        if (r > m) res = max(res, qry(rc, l, r));
        return res;
    }
};

void solve(){
    int n, m;
    cin >> n >> m;
    vector<LL> a(n + 1);
    vector<LL> add(n + 1, 0);
    vector<vector<LL>> g(n + 1);
    for (int i = 1;i <= n;i ++) cin >> a[i];
    for (int i = 1;i <= n - 1;i ++){
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    /*
        第一次dfs维护的东西：
        每个点的父节点 fa
        每个点的深度 dep
        每个点的子树大小 siz
        每个点的重孩子 son
    */
    vector<int> fa(n + 1, 0), vis(n + 1, 0), dep(n + 1, 0);
    vector<int> siz(n + 1, 0), son(n + 1, 0);
    auto dfs1 = [&](auto dfs1, int pu, int u) -> void {
        siz[u] = 1;
        fa[u] = pu;
        dep[u] = dep[pu] + 1;
        int Max = 0;
        for (auto v : g[u]){
            if (v == pu) continue;
            vis[v] = 1;
            dfs1(dfs1, u, v);
            siz[u] += siz[v];
            if (siz[v] > Max){
                Max = siz[v];
                son[u] = v;
            }
        }
    };
    /*
        第二次dfs维护的东西：
        重链头节点 top
        dfn序 dfn
        dfn序对应的点 seg
    */
    vector<int> top(n + 1, 0), dfn(n + 1, 0), seg(n + 1, 0);
    int cnt = 0;
    SegTree t(n + 1);
    t.build(1, 1, n);
    auto dfs2 = [&](auto dfs2, int head, int u) -> void {
        top[u] = head;
        dfn[u] = ++ cnt;
        seg[cnt] = u;
        t.upd(1, dfn[u], a[u]);
        if (son[u] == 0) return;
        dfs2(dfs2, head, son[u]);
        for (auto v : g[u]){
            if (v == fa[u] || v == son[u]) continue;
            dfs2(dfs2, v, v);
        }
    };
    dfs1(dfs1, 0, 1);
    dfs2(dfs2, 1, 1);
    auto qry = [&](int x, int y) -> LL {
        LL res = 0;
        while (dfn[top[x]] != dfn[top[y]]){
            if (dfn[top[x]] > dfn[top[y]]){
                res = max(res, t.qry(1, dfn[top[x]], dfn[x]));
                x = top[x];
                res = max(res, t.qry(1, dfn[x], dfn[x]) + add[fa[x]]);
                x = fa[x];
            } else{
                res = max(res, t.qry(1, dfn[top[y]], dfn[y]));
                y = top[y];
                res = max(res, t.qry(1, dfn[y], dfn[y]) + add[fa[y]]);
                y = fa[y];
            }
        }
        if (dfn[x] > dfn[y]) swap(x, y);

        res = max(res, t.qry(1, dfn[x], dfn[y]));
        if (top[fa[x]] != top[x])
            res = max(res, t.qry(1, dfn[x], dfn[x]) + add[fa[x]]);
        return res;
    };
    auto upd = [&](int p, int x) -> void {
        if (son[p]) 
            t.upd(1, dfn[son[p]], x);
        if (fa[p])
            t.upd(1, dfn[fa[p]], x);
        add[p] += x;
    };
    for (int i = 1;i <= m;i ++){
        int opt;
        cin >> opt;
        if (opt == 1){
            int u, v;
            cin >> u >> v;
            cout << qry(u, v) << '\n';
        } else if (opt == 2){
            LL u, v;
            cin >> u >> v;
            upd(u, v);
        }
    }
}

int main(){
    int T = 1;
    cin >> T;
    while (T --) solve();
}
~~~