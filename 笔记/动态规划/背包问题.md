# 背包问题DP
## 1）引入
背包容量为n，有m个物品。  
物品价值为 $v_1$，$v_2$...$v_m$。  
物品重量为 $w_1$，$w_2$...$w_m$。  
使背包内物品价值达到最大。

## 2）01背包问题
>每个物品只能被取一次
### 操作步骤
> 1. 将背包大小排列为0 ~ n  
> 2. 依次输入物品，与背包容量进行比较  
> * 若能放下，当前背包价值为$max(v_{max(不放该物品)},v_{放下该物品})$  
> * 若不能放下，当前背包价值为$max(放下该物品前)$  
### 举例
$n = 6, m = 3$  
$w_1 = 2, v_1 = 3$  
$w_2 = 3, v_2 = 5$  
$w_3 = 4, v_3 = 6$  
|n|0|1|2|3|4|5|6|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|0|0|0|0|
|$(w_1,v_1)=(2,3)$|0|0|3|3|3|3|3|
|$(w_2,v_2)=(3,5)$|0|0|3|5|5|8|8|
|$(w_3,v_3)=(4,6)$|0|0|3|5|6|8|9|
$\therefore v_{max} = 9$
### 代码
~~~cpp
int f[N][N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=1;j<=n;j++){
        if(j >= wi)
            f[i][j] = max(f[i-1][j-wi]+vi,f[i-1][j]);
        else
            f[i][j] = f[i-1][j];
    }
}
~~~
### 代码优化
~~~cpp
int f[N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=n;j>=wi;j--){
        f[j] = max(f[j],f[j-wi]+vi);
    }
}
~~~
## 3） 完全背包问题
> 每个物品可以被重复拿取

### 代码
~~~cpp
int f[N][N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=1;j<=v;j++){
        if(j >= wi)f[i][j] = max(f[i][j-wi]+vi,f[i-1][j]);
        else f[i][j] = f[i-1][j];
    }
}
~~~
### 代码优化
~~~cpp
int f[N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=wi;j<=n;j++){
        f[j] = max(f[j],f[j-wi]+vi);
    }
}
~~~
## 例题
>洛谷 (P1048 P1049 P1164)(01背包) P1616(完全背包) P1855(多维背包)