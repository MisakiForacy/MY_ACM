# 带权并查集(路径压缩)

### 思想

> 找到路径上的所有结点，利用**递归***记忆化*将其归为根结点

~~~cpp
void init(int n){   // 初始化
    for (int i=0;i<=n;i++){
        Set[i] = i;
    }
}
// > 查找时间复杂度：O(nlogn)
int findx(int x){      // 查询祖宗结点
    if (Set[x] != x){
        int fa = Set[x];
        Set[x] = findx(Set[x]);
        siz[x] += siz[fa];
    }
    return Set[x];
}
// > 归并时间复杂度：O(1)
void merge(int a,int b) {       // 归并
    int b = findx(b);
    int a = findx(a);
    if (a > b) swap(a,b);
    if (a != b){
        Set[b] = a;
        siz[a] += siz[b];
    }
}
~~~

# 树状数组

~~~cpp
#define lowbit(x) x&-x      // 获取lowbit
using namespace std;
using LL = long long;
const int N = 5e5+10;
int n,m,s[N];
void change(int x,int k){   // 进行单点修改
    while (x <= n){
        s[x] += k;
        x += lowbit(x);
    }
}
int query(int x){       // 查询从0到x的前缀和
    int t = 0;
    while (x){
        t += s[x];
        x -= lowbit(x);
    }
    return t;
}
int main(){
    cin >> n >> m;
    int op,x,y;
    for (int i=1;i<=n;i++){
        cin >> x;
        change(i,x);
    }
    for (int i=0;i<m;i++){
        cin >> op >> x >> y;
        if (op == 1){
            change(x,y);
        } else{
            cout << query(y) - query(x-1) << '\n';
        }
    }
}
~~~
  
# 线段树

~~~cpp
/*线段树*/
#define lc p<<1
#define rc p<<1|1
struct node{
    ll l,r,v,lazy;
};
node tr[4*N];
ll a[N];
void pushup(int p){
    tr[p].v = tr[lc].v + tr[rc].v;
}
void pushdown(int p){
    if (tr[p].lazy){
        tr[lc].v += tr[p].lazy * (tr[lc].r-tr[lc].l+1);
        tr[rc].v += tr[p].lazy * (tr[rc].r-tr[rc].l+1);
        tr[lc].lazy += tr[p].lazy;
        tr[rc].lazy += tr[p].lazy;
        tr[p].lazy = 0;
    }
}
void build(int p,int l,int r){
    tr[p] = {l,r,a[l],0};
    if (l==r) return;
    int m = (l + r) >> 1;
    build(lc,l,m);
    build(rc,m+1,r);
    pushup(p);
}
void update(int p,int x,int y,int k){
    if (x <= tr[p].l && tr[p].r <= y){
        tr[p].v += k * (tr[p].r-tr[p].l+1);
        tr[p].lazy += k;
        return;
    }
    int m = (tr[p].l+tr[p].r) >> 1;
    pushdown(p);
    if (x <= m) update(lc,x,y,k);
    if (y > m) update(rc,x,y,k);
    pushup(p);
}
ll query(int p,int x,int y){
    if (x <= tr[p].l && tr[p].r <= y){
        return tr[p].v;
    }
    int m = (tr[p].l+tr[p].r) >> 1;
    ll sum = 0;
    pushdown(p);
    if (x <= m) sum += query(lc,x,y);
    if (y > m) sum += query(rc,x,y);
    return sum;
}
~~~

# ST表 & RMQ问题

~~~cpp
int main(){
    int n,m,l,r;
    cin >> n >> m;
    int st[n+1][21];
    for (int i=1;i<=n;i++){
        cin >> st[i][0];
    }
    for (int i=1;i<=20;i++){
        for (int j=1;j+(1LL << i)-1 <= n;j++){
            st[j][i] = max(st[j][i-1],st[j+(1LL << i-1)][i-1]);
        }
    }
    while (m--){
        cin >> l >> r;
        int k = log2(r-l+1);
        cout << max(st[l][k],st[r-(1LL << k)+1][k]) << '\n';
    }
}
~~~

# 单调栈

~~~cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    vector<int> a(n+1),f(n+1);
    stack<int> stk;
    for (int i=1;i<=n;i++) cin >> a[i];
    for (int i=n;i>=1;i--){
        while (!stk.empty() && a[stk.top()]<=a[i]){
            stk.pop();
        }
        f[i] = stk.empty()?0:stk.top();
        stk.push(i);
    }
    for (int i=1;i<=n;i++){
        cout << f[i] << " \n"[i==n];
    }
}
~~~

# KMP

~~~cpp
vector<int> kmp(string t,string s){
    string str = t + '\0' + s;
    vector<int> pi(str.size(),0);
    for (int i=1;i<str.size();i++){
        int len = pi[i-1];
        while (len != 0 && str[i] != str[len]){
            len = pi[len - 1];
        }
        pi[i] = len + (str[i] == str[len]);
    }
    return pi;  // 最长前后缀匹配
}
~~~

# 字符串哈希

~~~cpp
using ULL = unsigned long long;
const int P = 131;
const int N = 1e5+10;
ULL p[N], h[N];
/*
求一个字符串的哈希值相当于求前缀和
求一个字符串的字串相当于求区间和
*/
// 预处理hash函数的前缀和
void init(){    
    p[0] = 1, h[0] = 0;
    for (int i=1;i<=n;i++){
        p[i] = p[i-1] * P;
        h[i] = h[i-1] * P + s[i];
    }
}
// 计算s[l~r]的hash值
ULL get(int l,int r){   
    return h[r] - h[l-1] * p[r-l+1];
}
// 判断两字串是否相同
bool substr(int l1,int r1,int l2,int r2){
    return get(l1,r1) == get(l2,r2);
}
~~~

# 杂七杂八的数论

1.定义$F$为斐波那契数列,如果$F_i$能被$k$整除,那么对于每一个$j$,$F_{i*j}$也能被$k$整除 (CF2033F)

2.斐波那契数列 MOD k,会得到一个周期数列

3.一定存在整数$x$,$y$,满足 $ax+by=\gcd(a,b)$ (裴属定理)

4.抛物线与直线所围成的面积$S_{AOB}$为阿基米德三角形$\triangle ABP$的$\frac{2}{3}$ (阿基米德三角形)
![avatar](https://bkimg.cdn.bcebos.com/pic/adaf2edda3cc7cd97c3f7cf13201213fb80e918c?x-bce-process=image/format,f_auto/watermark,image_d2F0ZXIvYmFpa2UyNzI,g_7,xp_5,yp_5,P_20/resize,m_lfit,limit_1,h_1080)

5.从0到x所有数的异或满足以下公式
$ XOR(0, x) = \begin{cases} x & \text{if } x \equiv 0 \pmod{4} \\ 1 & \text{if } x \equiv 1 \pmod{4} \\ x + 1 & \text{if } x \equiv 2 \pmod{4} \\ 0 & \text{if } x \equiv 3 \pmod{4} \end{cases}$ 

6.**逆元** 给定整数a，满足$gcd(a,m)=1$，方程&ax \mod m = 1&，x的所有解是a在模m意义下的逆，记作$a^{-1}$
$(a+b)\mod p = (a\mod p + b\mod p) \mod p$
$(a/b)\mod p = (a\mod p * b^{-1} \mod p) \mod p$

7.**筛法**

~~~cpp
int sieve[N];
int prime[N];
/*
埃拉托斯特尼筛法
对于任意一个大于 1 的正整数 n，
那么它的 x 倍就是合数（x > 1）。
利用这个结论，我们可以避免很多次不必要的检测。

如果我们从小到大考虑每个数，
然后同时把当前这个数的所有（比自己大的）倍数记为合数，
那么运行结束的时候没有被标记的数就是素数了。
*/
int Era(int n){
    int k = 0;
    for (int i=2;i*i<=n;i++){
        if (!sieve[i]){
            for (int j=i*i;j<=n;j+=i){
                sieve[j] = 1;
            }
        }
    }
    for (int i=2;i<=n;i++){
        if (!sieve[i]){
            prime[k++] = i;
        }
    }
    return k;
}

/*
欧拉筛法
*/
int Eular(int n){
    int k = 0;
    for (int i=2;i<=n;i++){
        if (!sieve[i]){
            prime[k++] = i;
        }   
        for (int j=0;j<k;j++){
            if (i * prime[j] > n) break;
            sieve[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return k;
}
~~~

8.**快速幂**

~~~cpp
LL qpow(LL a,LL x,LL mod){
    LL res = 1;
    while (x){
        if (x&1) res = res * a % mod;
        a = a * a % mod;
        x >>= 1;
    }
    return res;
}
~~~

9.**欧几里得算法求GCD**

~~~cpp
int gcd(int a, int b){
    return b == 0 ? a : gcd(b, a % b);
}
~~~

# 背包问题DP
## 1）引入
背包容量为n，有m个物品。  
物品价值为 $v_1$，$v_2$...$v_m$。  
物品重量为 $w_1$，$w_2$...$w_m$。  
使背包内物品价值达到最大。

## 2）01背包问题
>每个物品只能被取一次
### 操作步骤
> 1. 将背包大小排列为0 ~ n  
> 2. 依次输入物品，与背包容量进行比较  
> * 若能放下，当前背包价值为$max(v_{max(不放该物品)},v_{放下该物品})$  
> * 若不能放下，当前背包价值为$max(放下该物品前)$  
### 举例
$n = 6, m = 3$  
$w_1 = 2, v_1 = 3$  
$w_2 = 3, v_2 = 5$  
$w_3 = 4, v_3 = 6$  
|n|0|1|2|3|4|5|6|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|0|0|0|0|
|$(w_1,v_1)=(2,3)$|0|0|3|3|3|3|3|
|$(w_2,v_2)=(3,5)$|0|0|3|5|5|8|8|
|$(w_3,v_3)=(4,6)$|0|0|3|5|6|8|9|
$\therefore v_{max} = 9$
### 代码
~~~cpp
int f[N][N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=1;j<=n;j++){
        if(j >= wi)
            f[i][j] = max(f[i-1][j-wi]+vi,f[i-1][j]);
        else
            f[i][j] = f[i-1][j];
    }
}
~~~
### 代码优化
~~~cpp
int f[N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=n;j>=wi;j--){
        f[j] = max(f[j],f[j-wi]+vi);
    }
}
~~~
## 3） 完全背包问题
> 每个物品可以被重复拿取

### 代码
~~~cpp
int f[N][N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=1;j<=v;j++){
        if(j >= wi)f[i][j] = max(f[i][j-wi]+vi,f[i-1][j]);
        else f[i][j] = f[i-1][j];
    }
}
~~~
### 代码优化
~~~cpp
int f[N];
for(i=1;i<=m;i++){
    cin >> vi >> wi;
    for(j=wi;j<=n;j++){
        f[j] = max(f[j],f[j-wi]+vi);
    }
}
~~~
## 例题
>洛谷 (P1048 P1049 P1164)(01背包) P1616(完全背包) P1855(多维背包)